
# engine package

两个匹配引擎：NFA和JoinTree

为了减少数据拷贝操作，这里把事件缓存到一个Buffer里，
每个部分匹配由开始时间戳，终止时间戳，指向事件的指针组成

### TransitionCondition
转换条件类：
主要由事件类型约束，独立谓词约束，依赖谓词约束和下一状态组成.
此类定义的函数有：
1. 一个检查独立谓词约束的函数
2. 得到所有的依赖谓词列表


### State
状态类由6部分组成：状态名字+状态编号+转换条件+部分匹配缓存+是否是终止状态的标记+是否是开始状态的标记

注意：状态名字是根据查询模式的变量名指定的，因此对于两个状态，其状态名字可能相同

该类最核心的功能就是，当一个状态收到一个事件之后检查其是否能够转换成下一个状态，对应transition函数

具体步骤：
```
对于每个转换条件：
    ->如果这个事件能满足该转换条件对应的独立谓词：
      ->把这个事件插入到事件缓冲区中，并返回缓冲指针（int类型）
      ->如果这个状态是开始状态，则不需要检查依赖谓词，直接生成部分匹配并将其存放到下一个状态的buffer中
      ->如果这个状态不是开始状态，那么要检测每个依赖谓词
          ->检查所有的依赖谓词，看这个事件和之前的事件能否满足约束条件
          ->如果这个事件能够满足所有的依赖谓词约束条件
              ->看传入的是什么选择策略，如果是SKIP_TILL_NEXT_MATCH，则把当前匹配从缓冲删了
              ->生成新的匹配，并存放到下一个状态的匹配buffer中
```



假设事件模式是`SEQ(A v1, B v2, C v3)`
非确定性有限状态机NFA

注意当前状态机无法支持kleene算子和negation算子，
主要原因是negation算子和kleene算子匹配结果和查询的事件模式长度不匹配
（这样，导致PartialMatch结构处理逻辑会比较复杂）
如果没有依赖谓词的话，我们很容易扩展NFA支持kleene算子


注意：状态名字和变量名字绑定在一块
