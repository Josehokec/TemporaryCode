

# plan package
描述：这个包是用来产生计划的。假设我们有一个代价模型CostModel可以估计一个计划plan的代价，
那么枚举所有计划，然后使用代价模型来计算每个计划对应的代价，然后返回具有最低代价的计划

### 计划数量的计算
给定一个复杂/顺序模式查询，假设其模式长度（即变量长度）为n，每拉取一个变量对应的事件，
用来拉取的Filter假设只由一个变量对应的事件生成（注意可以传递空Filter），则所有拉取计划数量为：

$$
(n * 1) * ((n-1) * 2) * ((n - 3) * 3) * ... * (1 * n) = (n!)^2
$$

举个例子：假设查询的事件模式为`SEQ(A v1, B v2, C v3)`，则其模式长度为3，
则所有的拉取计划数量为$3! \times 3! = 36$.

| 模式长度 | 计划数量     |
|------|----------|
| 3    | 36       |
| 4    | 576      |
| 5    | 14400    |
| 6    | 518400   |
| 7    | 25401600 |

当模式长度大于等于5时，枚举出所有的计划显然变得非常耗时。
为此，我们需要采用合理的方式来避免枚举，一些常见的方式为：
1. 剪枝（剪掉一些无用的枝干）；
2. Monte Carlo simulation（随机选取一些计划）；
3. 贪心法（每次选取当前步骤最优的执行计划）；

具体选取哪一种方式有待考量。注意：我们这里对计划简化处理了，即每次只拉取一个事件

计划格式 `[VariableName, FilterName] -> [VariableName, FilterName]`

举个例子：假设查询模式是`SEQ(A v1, B v2, C v3)`，则一个可行计划是：
`[v1,null] -> [v2, Filter_v1] -> [v3, Filter_v2]`。

解释：主节点首先向其他节点请求变量v1对应的事件；
在获得v1变量对应的事件之后，主节点为变量`v1`对应的事件生成`Filter1`，
然后向其他节点请求变量v2对应的事件（这个过程会用`Filter1`过滤到无法参与匹配的事件）；
获得`v2`变量事件之后，我们为变量v2对应的事件生成`Filter2`（或者说是摘要），
然后向其他节点请求变量`v3`对应的事件（这个过程会用`Filter2`过滤到无法参与匹配的事件）。

这样我们就拉取到所有的变量对应的事件了，注意到我们实现的存储引擎要求输入事件是有序的，
因此我们需要对这些事件进行排序，排序完成后把这些事件放入到匹配引擎中产生匹配结果。
